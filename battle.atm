require "ts" ;; task prototypes for Ship, Shot, Meteor

;; Left/Right ship constant parameters

val V = @{
    l = @{                          ;; left ship
        tag = :L,
        pos = PP(10, 50),           ;; x,y initial position
        ctl = @{                    ;; key controls
            move  = @{ l='A', r='D', u='W', d='S'},
            frame = @{ l=0, r=1, u=2, d=3 },
            shot  = 'Left Shift',
        },
        lim = @{ x1=0, x2=W/2 },    ;; x limits (half of screen)
        shot = @{ tag=:l, x=1 },   ;; shot tag, x direction
        img = "imgs/ship-L.gif",    ;; ship image
    },
    r = @{
        tag = :R,
        pos = PP(90, 50),
        ctl = @{
            move = @{ l='Left', r='Right', u='Up', d='Down' },
            frame = @{ l=1, r=0, u=2, d=3 },
            shot = 'Right Shift',
        },
        lim = @{ x1=W/2, x2=W },
        shot = @{ tag=:r, x= -1 },
        img = "imgs/ship-R.gif",    ;; ship image
    },
}

;;;
;; Declares and spawns the game objects:
;;  - Meteors live in a dynamic pool of tasks and are spawned periodically.
;;  - Ships are fixed and held in a tuple pair.
;;  - Shots live in dynamic pools, one for each ship, which are held in a
;;    tuple pair.
;; Pools control the lifecycle of tasks by releasing them from memory
;; automatically on termination. Tasks in pools are anonymous and can only
;; be accessed through iterators or reference tracks.
;;;

func Battle () {
    ;; holds all meteors
    pin meteors = tasks()

    ;; holds all l/r shots (max of 3 simultaneous)
    pin shots_l = tasks(3)
    pin shots_r = tasks(3)

    ;; holds l/r ships
    pin ships = tasks(2)
    spawn [ships] Ship(V.l, shots_l)
    spawn [ships] Ship(V.r, shots_r)

    val s = watching ships {     ;; GAMEPLAY
        ;;;
        ;; Runs the gameplay until one of the two ships is destroyed:
        ;;  - Spawns new meteors periodically.
        ;;  - Checks collisions between all objects.
        ;;;
        par {                   ;; METEORS
            ;;;
            ;; Spawns new meteros in the game every period:
            ;;  - Hold them in the outer pool.
            ;;  - Gradually decreases the spawning period.
            ;;;
            loop {
                val dt = math.random(1000, 5000)
                await @.dt
                spawn [meteors] Meteor()
            }
        } with {
            every :clock { ;; COLLISIONS
                ;;;
                ;; Checks collisions between objects:
                ;;  1. Uses `to.vector` to collect all references to dinamically
                ;;     allocated ships, shots, and meteors.
                ;;  2. Uses `pico-collisions` to get all pairs of colliding
                ;;     objects, using the `f-cmp` comparator which relies on `:T`
                ;;     rect.
                ;;  3. Iterates over the pairs, ignores innocuous collisions, and
                ;;     collects final colliding objects.
                ;;  4. Signals colliding objects.
                ;; A ship collision will eventually terminate the enclosing
                ;; `watching`, also terminating the current battle.
                ;;;

                val ts = #{}
                loop _,t in ships {
                    set ts[#ts] = t
                }
                loop _,t in shots_l {
                    set ts[#ts] = t
                }
                loop _,t in shots_r {
                    set ts[#ts] = t
                }
                loop _,t in meteors {
                    set ts[#ts] = t
                }

                ;; check valid collisions within `ts` and emit 'collided'
                ;; (ignore ship 'R'/'r' shot, ship 'L'/'l' shot, 'M'/'M' meteors)
                loop _,t1 in ts {
                    loop _,t2 in ts {
                        val no = (
                            (t1 == t2) ||
                            ((t1.pub.tag==:R) && (t2.pub.tag==:r)) ||
                            ((t1.pub.tag==:r) && (t2.pub.tag==:R)) ||
                            ((t1.pub.tag==:L) && (t2.pub.tag==:l)) ||
                            ((t1.pub.tag==:l) && (t2.pub.tag==:L)) ||
                            ((t1.pub.tag==:M) && (t2.pub.tag==:M))
                        )
                        if (!no) && rect_vs_rect(t1.pub.rect, t2.pub.rect) {
                            emit [t1] :collided ;; will terminate t1
                            emit [t2] :collided ;; will terminate t2
                        }
                    }
                }
            }
        }
    }

    sdl.play "snds/explosion.wav"   ;; overrides any active sound

    ;;;
    ;; Returns the winner index to the main game loop:
    ;;  - 1, if ship[0] is dead
    ;;  - 0, if ship[1] is dead
    ;;;
    match s.pub.tag {       ;; BATTLE RESULT
        :L => :R
        :R => :L
    }
}

Battle
