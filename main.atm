set SDL = require "SDL"
set IMG = require "SDL.image"
set TTF = require "SDL.ttf"
set MIX = require "SDL.mixer"

set sdl = require "atmos.env.sdl"

;; SKIP TO "START HERE"

set PP = sdl.pct_to_pos
set rect_vs_rect = sdl.rect_vs_rect

SDL.init() --> assert
TTF.init() --> assert
MIX.openAudio(44100, SDL.audioFormat.S16, 2, 1024);

defer {
    MIX.quit()
    TTF.quit()
    SDL.quit()
}

set W, H = (640, 480)
set WIN = SDL.createWindow @{
	title  = "The Battle of Ships",
	width  = W,
	height = H,
    flags  = @{ SDL.flags.OpenGL },
} --> assert

set REN = SDL.createRenderer(WIN,-1) --> assert
set sdl.ren = REN

set FNT = TTF.open("tiny.ttf", H/15) --> assert

math.randomseed()

;; START HERE

val Battle = require "battle" ;; actual battle gameplay

spawn {    ;; BACKGROUND
    ;;;
    ;; This task is the first to spawn, which makes the background image to
    ;; always be rendered first.
    ;;;
    val sfc = IMG.load("imgs/bg.png") --> assert
    val tex = REN::createTextureFromSurface(sfc) --> assert
    every :sdl.draw {
        REN::copy(tex)
    }
}

val points = @{ L=0, R=0 }

spawn {    ;; POINTS
    ;;;
    ;; Spawns the players points and place them at the bottom of the screen, in
    ;; opposite sides.
    ;; Points are incremented when the ship of the opponent is destroyed.
    ;; Since points must outlive each individual battle, we spawn them here,
    ;; outside the main game loop.
    ;;;
    val l = PP(10, 90)
    val r = PP(90, 90)
    every :sdl.draw {
        REN::setDrawColor(0xFFFFFF)
        sdl.write(FNT, tostring(points.L), l)
        sdl.write(FNT, tostring(points.R), r)
    }
}

;; MAIN-LOOP
;;;
;; Starts the main game loop:
;;  - Shows the "press to start" message.
;;  - Runs the next battle with the actual gameplay.
;;  - Restarts whenever one of the ships is destroyed.
;;;
loop {
    ;; ENTER-TO-START
    watching SDL.event.KeyDown, :Return {
        ;;;
        ;; Spawns the blinking message, and awaits a :Return press.
        ;;;
        loop {
            ;; 500ms on
            watching @.500 {
                val pt = PP(50, 50)
                every :sdl.draw {
                    REN::setDrawColor(0xFFFFFF)
                    sdl.write(FNT, "= PRESS ENTER TO START =", pt)
                }
            }
            ;; 500ms off
            await @.500
        }
    }

    ;; Plays the restart sound.
    sdl.play "snds/start.wav"

    ;; spawns the actual battle
    pin battle = spawn Battle()

    ;; Pause with 'P':
    ;;  * awaits 'P' to toggle battle off
    ;;  * shows a "paused" image
    ;;  * awaits 'P' to toggle battle on
    spawn {
        loop {
            await(SDL.event.KeyDown, 'P')
            toggle battle(false)
            spawn {
                val sfc = IMG.load("imgs/pause.png") --> assert
                val tex = REN::createTextureFromSurface(sfc) --> assert
                val pt = PP(50, 50)
                val r = @{
                    x = (pt.x - (w/2)) --> math.floor,
                    y = (pt.y - (h/2)) --> math.floor,
                    w = w,
                    h = h,
                } where {
                    w,h = sfc::getSize()
                }
                every :sdl.draw {
                    REN::copy(tex, nil, r)
                }
            }
            await(SDL.event.KeyDown, 'P')
            toggle battle(true)
        }
    }

    ;; Battle terminates:
    ;;  * awaits battle to return winner
    ;;  * increments winner points
    ;;  * awaits 1s before next battle
    val winner = await(battle)
    set points[winner] = points[winner] + 1
    await @1

    ;;;
    ;; Restarts the main loop.
    ;; Due to lexical memory management, only the points are preserved
    ;; between loop iterations.
    ;; All other tasks are guaranteed to abort and be reclaimed after this
    ;; point.
    ;;;
}
