val SHIP_FRAMES     = 4
val SHIP_ACC_DIV    = 10
val SHIP_VEL_MAX    = @{ x=W/2.5, y=H/2.5 }
val SHOT_DIM        = @{ w=W/50-->math.floor, h=H/100-->math.floor }
val SHOT_COLOR      = 0xFFFF88
val METEOR_FRAMES   = 6
val METEOR_AWAIT    = 5000

func between (min, v, max) {
    ifs {
        v < min => min
        v > max => max
        else    => v
    }
}

func random_signal () {
    if (math.random(0,1) == 1) => 1 => -1
}

;; Simple "physics" to update Meteor/Shot `rect` position based on `vel` speed:
;;  * updates rect every 'step' frame
;;  * terminates when rect leaves the screen

func Move_T (rect, vel) {
    ;;;
    ;; Updates the given `rect` position according to its `vel` speed.
    ;;  - Updates on every :Frame.
    ;;  - Terminates when leaving the screen.
    ;;;
    watching out_of_screen {
        every :clock \(_,ms) {
            val dt = ms / 1000
            set rect.x = rect.x + (vel.x * dt) --> math.floor
            set rect.y = rect.y + (vel.y * dt) --> math.floor
        }
    } where {
        out_of_screen = func () {
            ifs {
                rect.x < 0 => true
                rect.x > W => true
                rect.y < 0 => true
                rect.y > H => true
                else       => false
            }
        }
    }
}

func Meteor () {
    val sfc = IMG.load("imgs/meteor.gif") --> assert
    val tex = REN::createTextureFromSurface(sfc) --> assert
    val ww,h = sfc::getSize()

    val y_sig = random_signal()

    val vx = (1 + (math.random(0,W/5))) * random_signal()
    val vy = (1 + (math.random(0,H/5))) * y_sig

    val w = ww / METEOR_FRAMES
    var dx = 0

    val rect = @{ x=x, y=y, w=w, h=h } where {
        x = math.random(0,W)
        y = if y_sig==1 => 0 => H
    }
    set pub = @{
        tag  = :M,
        rect = rect,
    }

    par_or {
        val dt = math.random(1, METEOR_AWAIT)
        await @.dt
        par_or {
            await Move_T(rect, @{x=vx,y=vy})
        } with {
            await :collided
            sdl.play "snds/meteor.wav"
        }
    } with {
        every :sdl.draw {
            val crop = @{ x=dx, y=0, w=w, h=h }
            REN::copy(tex, crop, rect)
        }
    } with {
        val v = ((vx->math.pow(2)) + (vy->math.pow(2))) --> math.pow(1/2)
        var x = 0
        every :clock \(_,ms) {
            set x = x + ((v * ms) / 1000)
            set dx = (x % ww) - (x % w)
        }
    }
}

func Shot (V, pos, vy) {
    sdl.play "snds/shot.wav"
    val rect = @{ x=pos.x+((V.x*SHOT_DIM.w)/2), y=(pos.y-(SHOT_DIM.h/2)), w=SHOT_DIM.w, h=SHOT_DIM.h }
    set pub = @{
        tag  = V.tag,
        rect = rect,
    }
    par_or {
        await :collided
    } with {
        await Move_T(rect, @{x=(W/3)*V.x, y=vy})
    } with {
        every :sdl.draw {
            REN::setDrawColor(SHOT_COLOR)
            REN::fillRect(rect)
        }
    }
}

func Ship (V, shots) {
    val sfc = IMG.load(V.img) --> assert
    val tex = REN::createTextureFromSurface(sfc) --> assert
    val w,h = sfc::getSize()
    val vel = @{x=0,y=0}
    val dy = h / SHIP_FRAMES
    val rect = @{ x=V.pos.x-(w/2), y=V.pos.y-(dy/2), w=w, h=dy }

    set pub = @{
        tag  = V.tag,
        rect = rect,
    }

    var acc = @{x=0,y=0}
    var key
    spawn {
        par {
            every SDL.event.KeyDown \{
                match it.name {
                    V.ctl.shot   => spawn [shots] Shot(V.shot, @{x=rect.x+(rect.w/2),y=rect.y+(rect.h/2)}, vel.y)
                    V.ctl.move.l => set acc.x = -W/SHIP_ACC_DIV
                    V.ctl.move.r => set acc.x =  W/SHIP_ACC_DIV
                    V.ctl.move.u => set acc.y = -H/SHIP_ACC_DIV
                    V.ctl.move.d => set acc.y =  H/SHIP_ACC_DIV
                }
                set key = it.name
            }
        } with {
            every SDL.event.KeyUp {
                set key = nil
                set acc = @{x=0,y=0}
            }
        }
    }

    watching :collided {
        par {
            every :sdl.draw {
                val frame = match key {
                    V.ctl.move.l => V.ctl.frame.l
                    V.ctl.move.r => V.ctl.frame.r
                    V.ctl.move.u => V.ctl.frame.u
                    V.ctl.move.d => V.ctl.frame.d
                    else => 0
                }
                val crop = @{ x=0, y=frame*dy, w=rect.w, h=dy }
                REN::copy(tex, crop, rect)
            }
        } with {
            every :clock \(_,ms) {
                val dt = ms / 1000
                set vel.x = between(-SHIP_VEL_MAX.x, vel.x+(acc.x*dt), SHIP_VEL_MAX.x)
                set vel.y = between(-SHIP_VEL_MAX.y, vel.y+(acc.y*dt), SHIP_VEL_MAX.y)

                val x = (rect.x + (vel.x*dt)) --> math.floor
                val y = (rect.y + (vel.y*dt)) --> math.floor
                set rect.x = between(V.lim.x1, x, V.lim.x2-w) --> math.floor
                set rect.y = between(0, y, H-dy) --> math.floor
            }
        }
    }

    watching @.150 {
        var d = dy / 2;
        par {
            every :clock \(_,ms) {
                set d = d + (((40*d)*ms)/1000)
            }
        } with {
            every :sdl.draw {
                REN::setDrawColor(0xFF0000)
                REN::fillRect @{ x=rect.x, y=rect.y, w=d, h=d }
            }
        }
    }
}
